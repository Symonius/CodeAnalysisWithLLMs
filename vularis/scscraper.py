import os
import re 

# Debug-Mode.
DEBUG = 0

# Only include these file types
extensions = {".cs"}


def is_auto_generated(file_path, lines_to_check=10):
    """
    Checks if a C# file contains the <auto-generated> tag in its header.
    This is efficient as it only reads the first few lines of the file.

    Args:
        file_path (str): The full path to the file to check.
        lines_to_check (int): The number of lines to read from the top.

    Returns:
        bool: True if the file is auto-generated, False otherwise.
    """
    try:
        # Use utf-8-sig to handle potential BOM (Byte Order Mark)
        with open(file_path, 'r', encoding='utf-8-sig', errors='ignore') as f:
            for i, line in enumerate(f):
                if i >= lines_to_check:
                    break  # Stop reading after checking the header
                # Case-insensitive check for robustness
                if "<auto-generated>" in line.lower():
                    return True
    except Exception as e:
        print(f"Warning: Could not read file {file_path} for check: {e}")
        return False  # Assume not generated if we can't read it
    
    return False


def get_all_files(folder_path):
    """
    Returns a sorted list of all file paths in the folder and subfolders,
    filtered by allowed extensions.
    """
    all_files = []
    for root, _, files in os.walk(folder_path):
        for file in sorted(files):
            _, ext = os.path.splitext(file)
            if ext.lower() in extensions:
                file_path = os.path.join(root, file)
                all_files.append(file_path)
    return all_files


def is_only_comments_or_whitespace(file_content):
    """
    Checks if the given C# file content consists only of comments and/or whitespace.
    This is a heuristic and might not be perfect for all edge cases (e.g., complex preprocessor directives
    that look like comments, or strings containing comment markers).

    Args:
        file_content (str): The entire content of the file.

    Returns:
        bool: True if content is only comments/whitespace, False otherwise.
    """
    
    # Make a copy to avoid modifying the original content if needed elsewhere
    cleaned_content = file_content

    # Remove multi-line comments first (important for cases like /* // */)
    # re.DOTALL makes '.' match newlines too
    cleaned_content = re.sub(r'/\*.*?\*/', '', cleaned_content, flags=re.DOTALL)

    # Remove single-line comments
    # This needs to be done line by line or carefully with regex to avoid issues
    # A simpler approach is to split by lines, clean each, then join.
    lines = cleaned_content.splitlines()
    cleaned_lines = []
    for line in lines:
        # Remove // comments
        line_without_single_comment = re.sub(r'//.*', '', line)
        cleaned_lines.append(line_without_single_comment)

    # Join lines back and remove all remaining whitespace
    final_cleaned_content = "".join(cleaned_lines)
    final_cleaned_content = re.sub(r'\s+', '', final_cleaned_content)

    # If nothing is left after removing comments and whitespace, it was only comments/whitespace
    return len(final_cleaned_content) == 0


def read_files_one_by_one(folder_path):
    """
    Generator that yields one filtered, NON-AUTO-GENERATED, NON-COMMENT-ONLY file's contents at a time.
    """
    files = get_all_files(folder_path)
    for i, file_path in enumerate(files):
        if is_auto_generated(file_path):
            #print(f"--> SKIPPING auto-generated file: {file_path}")
            continue

        try:
            with open(file_path, 'r', encoding='utf-8-sig') as f:
                content = f.read() # Read full content for comment check

            # First, check if it's empty or only whitespace (after stripping leading/trailing)
            stripped_content = content.lstrip().rstrip()
            if not stripped_content:
                #print(f"--> SKIPPING empty or whitespace-only file: {file_path}")
                continue

            # Then, check if it's only comments or whitespace
            if is_only_comments_or_whitespace(content):
                #print(f"--> SKIPPING file with only comments/whitespace: {file_path}")
                continue

            # If it passed all checks, yield the content (you can choose to lstrip here or later)
            if DEBUG:
                yield f"\n\n--- File {i+1}/{len(files)}: {file_path} ---\n\n{content}"
            else:
                yield file_path, content # Yield raw content or .lstrip() if preferred
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
            continue